# Инструкция для работы с Git и удалёнными репозиториями

![GIT](git-logo.png)

## Что такое Git? 
----
**Git** - это одна из реализаций распределённых систем контроля версий, имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире.

* ## Подготовка репозитория
Для создание репозитория необходимо выполнить команду __*git init*__  в папке с репозиторием и у Вас создаться репозиторий (появится скрытая папка _**.git**_)

* ## Создание коммитов

### Git add
Для добавления измений в коммит используется команда __*git add*__. Чтобы использовать команду *git add* напишите *git add <имя файла>*

### Просмотр состояния репозитория
Для того, чтобы посмотреть состояние репозитория используется команда __*git status*__. Для этого необходимо в папке с репозиторием написать *git status*, и Вы увидите были ли измения в файлах, или их не было.

### Создание коммитов
__*git commit*__
Для того, чтобы создать коммит(сохранение) необходимо выполнить команду __*git commit*__. Выполняется она так: *__git commit -m <сообщение к коммиту>__*. Все файлы для коммита должны быть ***ДОБАВЛЕНЫ*** и сообщение к коммиту писать ***ОБЯЗАТЕЛЬНО***.

__*git stash*__
Команда __*git stash*__ используется для временного сохраgitнения всех незафиксированных изменений с целью очистки рабочего каталога без необходимости фиксировать незавершённую работу в текущей ветке.

* ## Перемещение между сохранениями
Для того, чтобы перемещаться между коммитами, используется команда __*git checkout*__. Используется она в папке с пепозиторием следующим образом: ***git checkout <номер коммита>***

* ## Журнал изменений
Для того, чтобы посмтреть все сделанные изменения в репозитории, используется команда __*git log*__. Для этого достаточно выполнить команду *git log* в папке с репозиторием

_Для сокращения списка записей журнала можно использовать __*git log -n*__
Например при вводе  __*git log -2*__, будет получено всего 2 последних коммита._
___
## Ветки в Git

* ## Создание ветки

Для того, чтобы создать ветку, используется команда *git branch*. Делается это следующим образом в папке с репозиторием: 
__*git branch <название новой ветки>*__

* ## Слияние веток

Для того чтобы дабавить ветку в текущую ветку используется команда __*git merge <имя ветки>*__.

---
*Например мы хотим ветку черновика **graft**  совместить с веткой **master***

Необходимо:
1. Создать коммиты обеих веток.
2. Перейти на ветку, с которой необходимо произвести слияние с помощью команды __*git chechout <имя ветки>*__. В нашем случае __*git checkout master*__

3. Далее произвести слияние ветки *draft* и основной ветки *master*, в которой находимся. Т.е. выполняем комманду __*git merge draft*__

---

* ## Удаление веток
Для удаления ветки ввести команду __*git branch -d <имя ветки>*__.

* ## Сравнение веток
__*git diff*__
Команда ***git diff*** используется для вычисления разницы между любыми двумя ветками. Это может быть разница между вашей рабочей копией и индексом.
Используется также такие параметры как 
1. разница между индексом и последним коммитом ***git diff --staged***
2.  между любыми двумя коммитами ***git diff master branchB***.

*__git difftool__*
Команда __*git difftool*__ просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика **git diff**.
![difftool](difftool.png)

Чтобы выйти из утилиты, нужно выбрать в панеле терминалов корзинку, наведя на активный терминал **git**, либо переключится между терминалами.
![difftool_exit](difftoolkill.png)

## Конфликты слияния в Git
Дополнить материалом, к примеру https://www.atlassian.com/ru/git/tutorials/using-branches/merge-conflicts


___

# Совместная работа и обновление проектов
Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

***git fetch***
Команда ***git fetch*** связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

***git pull***
Команда ***git pull*** работает как комбинация команд **git fetch и git merge**, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

***git push***
Команда ***git push*** используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

***git remote***
*git remote add <имя> <ссылка>*
Команда git remote служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например «origin», так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

***git archive***
Команда ***git archive*** используется для упаковки в архив указанных коммитов или всего репозитория.

***git submodule***
Команда ***git submodule*** используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.

## Клонирование существующего репозитория
Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду ***git clone***. Если вы знакомы с другими системами контроля версий, такими как Subversion, то заметите, что команда называется «clone», а не «checkout». Это важное различие — вместо того, чтобы просто получить рабочую копию, **Git получает копию практически всех данных, которые есть на сервере**. При выполнении ***git clone*** с сервера забирается (pulled) каждая версия каждого файла из истории проекта.

 > Создание ответвлений (fork)
Если вы хотите вносить свой вклад в уже существующие проекты, в которых у нас нет прав на внесения изменений путём отправки (push) изменений, вы можете создать своё собственное ответвление (fork) проекта. Это означает, что GitHub создаст вашу собственную копию проекта, данная копия будет находиться в вашем пространстве имён и вы сможете легко делать изменения путём отправки (push) изменений. 